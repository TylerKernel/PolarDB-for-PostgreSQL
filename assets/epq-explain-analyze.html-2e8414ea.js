import{_ as r,r as o,o as k,c as d,d as n,a as s,w as p,b as a,e as i}from"./app-eb0c2f94.js";const u={},y=s("h1",{id:"epq-执行计划查看与分析",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#epq-执行计划查看与分析","aria-hidden":"true"},"#"),a(" ePQ 执行计划查看与分析")],-1),w={class:"table-of-contents"},m=i(`<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>PostgreSQL 提供了 <code>EXPLAIN</code> 命令用于 SQL 语句的性能分析。它能够输出 SQL 对应的查询计划，以及在执行过程中的具体耗时、资源消耗等信息，可用于排查 SQL 的性能瓶颈。</p><p><code>EXPLAIN</code> 命令原先只适用于单机执行的 SQL 性能分析。PolarDB-PG 的 ePQ 弹性跨机并行查询扩展了 <code>EXPLAIN</code> 的功能，使其可以打印 ePQ 的跨机并行执行计划，还能够统计 ePQ 执行计划在各个算子上的执行时间、数据扫描量、内存使用量等信息，并以统一的视角返回给客户端。</p><h2 id="功能介绍" tabindex="-1"><a class="header-anchor" href="#功能介绍" aria-hidden="true">#</a> 功能介绍</h2><h3 id="执行计划查看" tabindex="-1"><a class="header-anchor" href="#执行计划查看" aria-hidden="true">#</a> 执行计划查看</h3><p>ePQ 的执行计划是分片的。每个计划分片（Slice）由计算节点上的虚拟执行单元（Segment）启动的一组进程（Gang）负责执行，完成 SQL 的一部分计算。ePQ 在执行计划中引入了 Motion 算子，用于在执行不同计划分片的进程组之间进行数据传递。因此，Motion 算子就是计划分片的边界。</p><p>ePQ 中总共引入了三种 Motion 算子：</p><ul><li><code>PX Coordinator</code>：源端数据发送到同一个目标端（汇聚）</li><li><code>PX Broadcast</code>：源端数据发送到每一个目标端（广播）</li><li><code>PX Hash</code>：源端数据经过哈希计算后发送到某一个目标端（重分布）</li></ul><p>以一个简单查询作为例子：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_enable_px <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token punctuation">(</span>COSTS <span class="token keyword">OFF</span><span class="token punctuation">)</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">;</span>
                   QUERY <span class="token keyword">PLAN</span>
<span class="token comment">-------------------------------------------------</span>
 <span class="token keyword">Limit</span>
   <span class="token operator">-</span><span class="token operator">&gt;</span>  PX Coordinator <span class="token number">6</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">6</span><span class="token punctuation">)</span>
         <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> t
 Optimizer: PolarDB PX Optimizer
<span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">rows</span><span class="token punctuation">)</span>
</code></pre></div><p>以上执行计划以 Motion 算子为界，被分为了两个分片：一个是接收最终结果的分片 <code>slice0</code>，一个是扫描数据的分片<code>slice1</code>。对于 <code>slice1</code> 这个计划分片，ePQ 将使用六个执行单元（<code>segments: 6</code>）分别启动一个进程来执行，这六个进程各自负责扫描表的一部分数据（<code>Partial Seq Scan</code>），通过 Motion 算子将六个进程的数据汇聚到一个目标端（<code>PX Coordinator 6:1</code>），传递给 <code>Limit</code> 算子。</p><p>如果查询逐渐复杂，则执行计划中的计划分片和 Motion 算子会越来越多：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1 <span class="token punctuation">(</span>a <span class="token keyword">INT</span><span class="token punctuation">,</span> b <span class="token keyword">INT</span><span class="token punctuation">,</span> c <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_enable_px <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token punctuation">(</span>COSTS <span class="token keyword">OFF</span><span class="token punctuation">)</span> <span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> a <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">;</span>
                         QUERY <span class="token keyword">PLAN</span>
<span class="token comment">------------------------------------------------------------</span>
 <span class="token keyword">Limit</span>
   <span class="token operator">-</span><span class="token operator">&gt;</span>  PX Coordinator <span class="token number">6</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">6</span><span class="token punctuation">)</span>
         <span class="token operator">-</span><span class="token operator">&gt;</span>  GroupAggregate
               <span class="token keyword">Group</span> <span class="token keyword">Key</span>: a
               <span class="token operator">-</span><span class="token operator">&gt;</span>  Sort
                     Sort <span class="token keyword">Key</span>: a
                     <span class="token operator">-</span><span class="token operator">&gt;</span>  PX <span class="token keyword">Hash</span> <span class="token number">6</span>:<span class="token number">6</span>  <span class="token punctuation">(</span>slice2<span class="token punctuation">;</span> segments: <span class="token number">6</span><span class="token punctuation">)</span>
                           <span class="token keyword">Hash</span> <span class="token keyword">Key</span>: a
                           <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> t1
 Optimizer: PolarDB PX Optimizer
<span class="token punctuation">(</span><span class="token number">10</span> <span class="token keyword">rows</span><span class="token punctuation">)</span>
</code></pre></div><p>以上执行计划中总共有三个计划分片。将会有六个进程（<code>segments: 6</code>）负责执行 <code>slice2</code> 分片，分别扫描表的一部分数据，然后通过 Motion 算子（<code>PX Hash 6:6</code>）将数据重分布到另外六个（<code>segments: 6</code>）负责执行 <code>slice1</code> 分片的进程上，各自完成排序（<code>Sort</code>）和聚合（<code>GroupAggregate</code>），最终通过 Motion 算子（<code>PX Coordinator 6:1</code>）将数据汇聚到结果分片 <code>slice0</code>。</p>`,14);function g(t,P){const c=o("Badge"),l=o("ArticleInfo"),e=o("router-link");return k(),d("div",null,[y,n(c,{type:"tip",text:"V11 / v1.1.20-",vertical:"top"}),n(l,{frontmatter:t.$frontmatter},null,8,["frontmatter"]),s("nav",w,[s("ul",null,[s("li",null,[n(e,{to:"#背景"},{default:p(()=>[a("背景")]),_:1})]),s("li",null,[n(e,{to:"#功能介绍"},{default:p(()=>[a("功能介绍")]),_:1}),s("ul",null,[s("li",null,[n(e,{to:"#执行计划查看"},{default:p(()=>[a("执行计划查看")]),_:1})])])])])]),m])}const _=r(u,[["render",g],["__file","epq-explain-analyze.html.vue"]]);export{_ as default};
